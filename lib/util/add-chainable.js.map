{"version":3,"sources":["util/add-chainable.js"],"names":[],"mappings":";;;;;;;;;;;;;;;qBAkBwB,YAAY;;;;;uBAPX,WAAW;;;;2BACX,gBAAgB;;;;AAEzC,IAAM,KAAK,GAAW,QAAQ,CAAC,SAAS,CAAC,KAAK,CAAC;;;;AAIhC,SAAS,YAAY,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE;AAC7D,MAAI,OAAO,GAAG,KAAK,UAAU,EAAE;AAAE,OAAG,GAAG,YAAW,EAAG,CAAC;GAAE;;AAExD,MAAM,QAAQ,GAAG,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC;;;AAG1C,MAAI,CAAC,OAAO,sBAAS,EAAE;AAAE,WAAO,sBAAS,GAAG,EAAG,CAAC;GAAE;AAClD,SAAO,sBAAS,CAAC,IAAI,CAAC,GAAG,QAAQ,CAAC;;;AAGlC,QAAM,CAAC,cAAc,CAAC,OAAO,EAAE,IAAI,EAAE;AACnC,gBAAY,EAAE,IAAI;AAClB,OAAG,EAAE,eAAW;;;AAGd,UAAI,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;AACnC,UAAI,IAAI,KAAK,SAAS,EAAE;AAAE,YAAI,GAAG,IAAI,CAAC;OAAE;AACxC,UAAI,CAAC,8BAAY,IAAI,CAAC,EAAE;AACtB,cAAM,IAAI,KAAK,CAAC,oDAAoD,CAAC,CAAC;OACvE;;;AAGD,UAAM,OAAO,GAAG,SAAS,OAAO,GAAG;AACjC,YAAM,MAAM,GAAG,QAAQ,CAAC,IAAI,CAAC,KAAK,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;AACpD,YAAI,GAAG,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;AAChC,eAAO,MAAM,KAAK,SAAS,GAAG,IAAI,GAAG,MAAM,CAAC;OAC7C,CAAC;;;AAGF,UAAM,SAAS,GAAG,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;AACtC,YAAM,CAAC,cAAc,CAAC,OAAO,EAAE,SAAS,CAAC,CAAC;AAC1C,eAAS,CAAC,IAAI,GAAI,IAAI,CAAC;AACvB,eAAS,CAAC,KAAK,GAAG,KAAK,CAAC;;AAExB,UAAI,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;AAC5C,aAAO,OAAO,CAAC;KAChB;GACF,CAAC,CAAC;CAEJ","file":"util/add-chainable.js","sourcesContent":["/**\n * Schematik.util.addChainable\n *\n * @author          Denis Luchkin-Zhou <wyvernzora@gmail.com>\n * @license         MIT\n */\n\n\n// This file is a Schematik-specific ES6 rewrite of:\n//   chaijs/chai/lib/chai/utils/addChainableMethod.js\n\nimport methods      from './symbols';\nimport isSchematik  from './is-schematik';\n\nconst apply         = Function.prototype.apply;\n\n\n// Adds a chainable method to the specified object\nexport default function addChainable(context, name, call, get) {\n  if (typeof get !== 'function') { get = function() { }; }\n\n  const behavior = { call: call, get: get };\n\n  // Save methods for later overwrites\n  if (!context[methods]) { context[methods] = { }; }\n  context[methods][name] = behavior;\n\n  // Attach the chainable method to the object\n  Object.defineProperty(context, name, {\n    configurable: true,\n    get: function() {\n      // Allow onGet to make changes to the Schematik\n      // If changes are made, a new Schematik will be returned\n      let self = behavior.get.call(this);\n      if (self === undefined) { self = this; }\n      if (!isSchematik(self)) {\n        throw new Error('get() must return a Schematik object or undefined.');\n      }\n\n      // Construct the wrapper function for the onCall\n      const wrapper = function wrapper() {\n        const result = behavior.call.apply(self, arguments);\n        self = self.flag('chain', null);\n        return result === undefined ? self : result;\n      };\n\n      // Make the wrapper act like Schematik\n      const prototype = Object.create(self);\n      Object.setPrototypeOf(wrapper, prototype);\n      prototype.call  = call;\n      prototype.apply = apply;\n\n      self.flag('chain', wrapper).copyTo(wrapper);\n      return wrapper;\n    }\n  });\n\n}\n"],"sourceRoot":"/source/"}